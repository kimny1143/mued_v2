import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { neon } from '@neondatabase/serverless';
import { z } from 'zod';

// Initialize database connection
const sql = neon(process.env.DATABASE_URL!);

// Validation schemas
const CreateFragmentSchema = z.object({
  content: z.string().min(1).max(10000),
  projectId: z.string().uuid().optional(),
  importance: z.enum(['low', 'medium', 'high', 'critical']).optional(),
});

const UpdateFragmentSchema = z.object({
  id: z.string().uuid(),
  content: z.string().min(1).max(10000).optional(),
  projectId: z.string().uuid().nullable().optional(),
  importance: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  status: z.enum(['pending', 'processing', 'completed', 'failed', 'archived']).optional(),
});

// Helper to get user ID from auth or dev token
async function getUserId(req: NextRequest) {
  const { userId: clerkUserId } = await auth();

  if (!clerkUserId) {
    const authHeader = req.headers.get('authorization');

    // Check for dev token - validate against environment variable
    const expectedDevToken = process.env.DEV_AUTH_TOKEN || 'dev_token_kimny';
    if (authHeader === `Bearer ${expectedDevToken}`) {
      // In development, use the dev user
      const users = await sql`
        SELECT id FROM users WHERE email = 'kimny1143@gmail.com'
      `;

      if (users.length > 0) {
        return users[0].id;
      }
    }

    return null;
  }

  // Get user ID from Clerk user
  const users = await sql`
    SELECT id FROM users WHERE clerk_id = ${clerkUserId}
  `;

  return users.length > 0 ? users[0].id : null;
}

// GET /api/muednote/fragments
export async function GET(req: NextRequest) {
  try {
    const userId = await getUserId(req);

    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = req.nextUrl.searchParams;
    const projectId = searchParams.get('projectId');
    const status = searchParams.get('status') || 'pending';
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 100);
    const offset = Math.max(parseInt(searchParams.get('offset') || '0'), 0);

    // Build query based on filters - using tagged template literals
    let fragments;

    if (projectId && status) {
      fragments = await sql`
        SELECT
          f.*,
          p.name as project_name,
          p.color as project_color,
          COALESCE(
            json_agg(
              json_build_object(
                'id', t.id,
                'name', t.name,
                'color', t.color,
                'confidence', ft.confidence,
                'isAutoGenerated', ft.is_auto_generated
              )
            ) FILTER (WHERE t.id IS NOT NULL),
            '[]'::json
          ) as tags
        FROM muednote_v3.fragments f
        LEFT JOIN muednote_v3.projects p ON f.project_id = p.id
        LEFT JOIN muednote_v3.fragment_tags ft ON f.id = ft.fragment_id
        LEFT JOIN muednote_v3.tags t ON ft.tag_id = t.id
        WHERE f.user_id = ${userId}
          AND f.project_id = ${projectId}
          AND f.status = ${status}
        GROUP BY f.id, p.name, p.color
        ORDER BY f.created_at DESC
        LIMIT ${limit}
        OFFSET ${offset}
      `;
    } else if (projectId) {
      fragments = await sql`
        SELECT
          f.*,
          p.name as project_name,
          p.color as project_color,
          COALESCE(
            json_agg(
              json_build_object(
                'id', t.id,
                'name', t.name,
                'color', t.color,
                'confidence', ft.confidence,
                'isAutoGenerated', ft.is_auto_generated
              )
            ) FILTER (WHERE t.id IS NOT NULL),
            '[]'::json
          ) as tags
        FROM muednote_v3.fragments f
        LEFT JOIN muednote_v3.projects p ON f.project_id = p.id
        LEFT JOIN muednote_v3.fragment_tags ft ON f.id = ft.fragment_id
        LEFT JOIN muednote_v3.tags t ON ft.tag_id = t.id
        WHERE f.user_id = ${userId}
          AND f.project_id = ${projectId}
        GROUP BY f.id, p.name, p.color
        ORDER BY f.created_at DESC
        LIMIT ${limit}
        OFFSET ${offset}
      `;
    } else if (status) {
      fragments = await sql`
        SELECT
          f.*,
          p.name as project_name,
          p.color as project_color,
          COALESCE(
            json_agg(
              json_build_object(
                'id', t.id,
                'name', t.name,
                'color', t.color,
                'confidence', ft.confidence,
                'isAutoGenerated', ft.is_auto_generated
              )
            ) FILTER (WHERE t.id IS NOT NULL),
            '[]'::json
          ) as tags
        FROM muednote_v3.fragments f
        LEFT JOIN muednote_v3.projects p ON f.project_id = p.id
        LEFT JOIN muednote_v3.fragment_tags ft ON f.id = ft.fragment_id
        LEFT JOIN muednote_v3.tags t ON ft.tag_id = t.id
        WHERE f.user_id = ${userId}
          AND f.status = ${status}
        GROUP BY f.id, p.name, p.color
        ORDER BY f.created_at DESC
        LIMIT ${limit}
        OFFSET ${offset}
      `;
    } else {
      fragments = await sql`
        SELECT
          f.*,
          p.name as project_name,
          p.color as project_color,
          COALESCE(
            json_agg(
              json_build_object(
                'id', t.id,
                'name', t.name,
                'color', t.color,
                'confidence', ft.confidence,
                'isAutoGenerated', ft.is_auto_generated
              )
            ) FILTER (WHERE t.id IS NOT NULL),
            '[]'::json
          ) as tags
        FROM muednote_v3.fragments f
        LEFT JOIN muednote_v3.projects p ON f.project_id = p.id
        LEFT JOIN muednote_v3.fragment_tags ft ON f.id = ft.fragment_id
        LEFT JOIN muednote_v3.tags t ON ft.tag_id = t.id
        WHERE f.user_id = ${userId}
        GROUP BY f.id, p.name, p.color
        ORDER BY f.created_at DESC
        LIMIT ${limit}
        OFFSET ${offset}
      `;
    }

    // Get total count for pagination
    let countResult;

    if (projectId && status) {
      countResult = await sql`
        SELECT COUNT(*) as total
        FROM muednote_v3.fragments f
        WHERE f.user_id = ${userId}
          AND f.project_id = ${projectId}
          AND f.status = ${status}
      `;
    } else if (projectId) {
      countResult = await sql`
        SELECT COUNT(*) as total
        FROM muednote_v3.fragments f
        WHERE f.user_id = ${userId}
          AND f.project_id = ${projectId}
      `;
    } else if (status) {
      countResult = await sql`
        SELECT COUNT(*) as total
        FROM muednote_v3.fragments f
        WHERE f.user_id = ${userId}
          AND f.status = ${status}
      `;
    } else {
      countResult = await sql`
        SELECT COUNT(*) as total
        FROM muednote_v3.fragments f
        WHERE f.user_id = ${userId}
      `;
    }
    const total = parseInt(countResult[0].total);

    return NextResponse.json({
      fragments: fragments.map(f => ({
        ...f,
        projectName: f.project_name,
        projectColor: f.project_color,
        tags: f.tags || []
      })),
      pagination: {
        total,
        limit,
        offset,
        hasMore: offset + limit < total
      }
    });

  } catch (error) {
    console.error('Error fetching fragments:', error);
    return NextResponse.json(
      { error: 'Failed to fetch fragments' },
      { status: 500 }
    );
  }
}

// POST /api/muednote/fragments
export async function POST(req: NextRequest) {
  try {
    const userId = await getUserId(req);

    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();

    // Validate request body
    const validationResult = CreateFragmentSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Invalid request data', details: validationResult.error.issues },
        { status: 400 }
      );
    }

    const { content, projectId, importance = 'medium' } = validationResult.data;

    const fragment = await sql`
      INSERT INTO muednote_v3.fragments (
        user_id,
        content,
        project_id,
        importance,
        status,
        captured_at
      ) VALUES (
        ${userId},
        ${content},
        ${projectId || null},
        ${importance},
        'pending',
        NOW()
      ) RETURNING *
    `;

    return NextResponse.json({
      fragment: fragment[0],
      message: 'Fragment created successfully'
    });

  } catch (error) {
    console.error('Error creating fragment:', error);
    return NextResponse.json(
      { error: 'Failed to create fragment' },
      { status: 500 }
    );
  }
}

// PATCH /api/muednote/fragments
export async function PATCH(req: NextRequest) {
  try {
    const userId = await getUserId(req);

    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();

    // Validate request body
    const validationResult = UpdateFragmentSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Invalid request data', details: validationResult.error.issues },
        { status: 400 }
      );
    }

    const { id, content, projectId, importance, status } = validationResult.data;

    // Check if fragment exists and belongs to user
    const checkFragment = await sql`
      SELECT id FROM muednote_v3.fragments
      WHERE id = ${id} AND user_id = ${userId}
    `;

    if (checkFragment.length === 0) {
      return NextResponse.json(
        { error: 'Fragment not found' },
        { status: 404 }
      );
    }

    // Handle multiple field updates
    let fragment;

    // Special case for archiving - set archived_at
    if (status === 'archived') {
      fragment = await sql`
        UPDATE muednote_v3.fragments
        SET status = 'archived',
            archived_at = NOW(),
            updated_at = NOW(),
            content = COALESCE(${content || null}, content),
            project_id = COALESCE(${projectId !== undefined ? projectId : null}, project_id),
            importance = COALESCE(${importance || null}, importance)
        WHERE id = ${id} AND user_id = ${userId}
        RETURNING *
      `;
    } else {
      // Update all provided fields at once
      fragment = await sql`
        UPDATE muednote_v3.fragments
        SET
          content = COALESCE(${content || null}, content),
          project_id = ${projectId !== undefined ? projectId : 'KEEP_CURRENT'},
          importance = COALESCE(${importance || null}, importance),
          status = COALESCE(${status || null}, status),
          updated_at = NOW()
        WHERE id = ${id} AND user_id = ${userId}
          AND ('KEEP_CURRENT' = 'KEEP_CURRENT' OR project_id IS NOT NULL)
        RETURNING *
      `;

      // If projectId needs to be updated, handle it separately
      if (projectId !== undefined) {
        fragment = await sql`
          UPDATE muednote_v3.fragments
          SET
            project_id = ${projectId},
            updated_at = NOW()
          WHERE id = ${id} AND user_id = ${userId}
          RETURNING *
        `;
      }
    }

    if (fragment.length === 0) {
      return NextResponse.json(
        { error: 'Failed to update fragment' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      fragment: fragment[0],
      message: 'Fragment updated successfully'
    });

  } catch (error) {
    console.error('Error updating fragment:', error);
    return NextResponse.json(
      { error: 'Failed to update fragment' },
      { status: 500 }
    );
  }
}

// DELETE /api/muednote/fragments
export async function DELETE(req: NextRequest) {
  try {
    const userId = await getUserId(req);

    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = req.nextUrl.searchParams;
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'Fragment ID is required' },
        { status: 400 }
      );
    }

    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(id)) {
      return NextResponse.json(
        { error: 'Invalid fragment ID format' },
        { status: 400 }
      );
    }

    const result = await sql`
      DELETE FROM muednote_v3.fragments
      WHERE id = ${id} AND user_id = ${userId}
      RETURNING id
    `;

    if (result.length === 0) {
      return NextResponse.json(
        { error: 'Fragment not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      message: 'Fragment deleted successfully'
    });

  } catch (error) {
    console.error('Error deleting fragment:', error);
    return NextResponse.json(
      { error: 'Failed to delete fragment' },
      { status: 500 }
    );
  }
}