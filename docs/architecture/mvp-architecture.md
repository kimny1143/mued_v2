# MVPå‘ã‘ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

## ğŸ“Œ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæƒ…å ±

- **ä½œæˆæ—¥**: 2025å¹´10æœˆ1æ—¥
- **æ›´æ–°æ—¥**: 2025å¹´10æœˆ1æ—¥
- **ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰
- **ç›®çš„**: POCã‹ã‚‰äº‹æ¥­è¨ˆç”»æ›¸è¦ä»¶ã‚’æº€ãŸã™MVPã¸ã®æŠ€è¡“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ
- **å¯¾è±¡èª­è€…**: é–‹ç™ºè€…ã€ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆã€æŠ€è¡“æ„æ€æ±ºå®šè€…

---

## ğŸ¯ ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

æœ¬æ–‡æ›¸ã¯ã€MUEDãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’POCæ®µéšã‹ã‚‰MVPã¸ç§»è¡Œã™ã‚‹ãŸã‚ã®**ç°¡ç´ åŒ–ã•ã‚ŒãŸã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ**ã‚’å®šç¾©ã—ã¾ã™ã€‚OpenAI Function Callingã‚’æ´»ç”¨ã—ãŸè‡ªç„¶è¨€èªå‡¦ç†ã¨ã‚·ãƒ³ãƒ—ãƒ«ãªREST APIã«ã‚ˆã‚‹å®Ÿè£…ã§ã€**150æ™‚é–“ï¼ˆ43æ—¥é–“ï¼‰**ã§ã®å®Ÿè£…ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚

### ä¸»è¦ãªæŠ€è¡“é¸å®š

| æ©Ÿèƒ½é ˜åŸŸ | æ¡ç”¨æŠ€è¡“ | é¸å®šç†ç”± |
|---------|----------|---------|
| è‡ªç„¶è¨€èªå‡¦ç† | OpenAI Function Calling | å®Ÿè£…ã‚·ãƒ³ãƒ—ãƒ«ã€ä½ã‚³ã‚¹ãƒˆ |
| APIå±¤ | Next.js API Routes | çµ±ä¸€çš„ãªé–‹ç™ºç’°å¢ƒ |
| èªè¨¼ | Clerk | POCã§å®Ÿç¸¾ã‚ã‚Š |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ | Neon PostgreSQL | Drizzle ORMã§é«˜é€Ÿã‚¢ã‚¯ã‚»ã‚¹ |
| æ±ºæ¸ˆ | Stripe | ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³å¯¾å¿œ |

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ–¹é‡

- âœ… **ãƒ¢ãƒãƒªã‚·ãƒƒã‚¯æ§‹æˆ**ã§é–‹å§‹ï¼ˆãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–ã¯å°†æ¥çš„ã«æ¤œè¨ï¼‰
- âœ… **æ—¢å­˜æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯**ã‚’æœ€å¤§é™æ´»ç”¨
- âœ… **OpenAI Function Calling**ã§è‡ªç„¶è¨€èªâ†’ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã‚’å®Ÿç¾
- âœ… **ã‚·ãƒ³ãƒ—ãƒ«ãªREST API**ã§è¤‡é›‘æ€§ã‚’å›é¿
- âŒ MCPã¯æ¡ç”¨ã—ãªã„ï¼ˆPhase 2ä»¥é™ã§æ¤œè¨å¯èƒ½ï¼‰

---

## ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“å›³

### MVPã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰

```mermaid
graph TB
    subgraph "Frontend Layer"
        WEB[Next.js App Router]
        NLI[è‡ªç„¶è¨€èªå…¥åŠ›]
        SUI[æ§‹é€ åŒ–UI]
    end

    subgraph "API Layer"
        APIGW[Next.js API Routes]
        AUTH[Clerk Middleware]
        RATE[Rate Limiting]

        subgraph "OpenAI Integration"
            INTENT[æ„å›³è§£æ<br/>Function Calling]
            TOOLS[ãƒ„ãƒ¼ãƒ«å®šç¾©]
        end
    end

    subgraph "Service Layer"
        SUB[Subscription Service]
        PAY[Payment Service]
        AI[AI Service]
        MATCH[Matching Service]
        RES[Reservation Service]
    end

    subgraph "Data Layer"
        DB[(Neon PostgreSQL)]
        CACHE[(Redis/Upstash)]
        QUEUE[Job Queue<br/>BullMQ]
    end

    subgraph "External Services"
        STRIPE[Stripe API]
        OPENAI[OpenAI API]
        EMAIL[Resend]
        GCAL[Google Calendar API]
    end

    NLI --> INTENT
    SUI --> APIGW
    WEB --> APIGW

    INTENT --> TOOLS
    TOOLS --> APIGW

    APIGW --> AUTH
    AUTH --> RATE

    RATE --> SUB
    RATE --> PAY
    RATE --> AI
    RATE --> MATCH
    RATE --> RES

    SUB --> DB
    PAY --> STRIPE
    AI --> OPENAI
    MATCH --> DB
    RES --> DB

    SUB --> CACHE
    AI --> CACHE

    PAY --> QUEUE
    AI --> QUEUE

    RES -.->|äºˆç´„ç¢ºå®š/ã‚­ãƒ£ãƒ³ã‚»ãƒ«| GCAL
    MATCH -.->|ç©ºãæ åŒæœŸ| GCAL

    QUEUE --> EMAIL
```

---

## ğŸ”„ è‡ªç„¶è¨€èªå‡¦ç†ãƒ•ãƒ­ãƒ¼

### OpenAI Function Callingã«ã‚ˆã‚‹å®Ÿè£…

```typescript
// /app/api/ai/intent/route.ts
import { openai } from '@/lib/openai';
import { NextRequest, NextResponse } from 'next/server';

// ãƒ„ãƒ¼ãƒ«å®šç¾©ï¼ˆOpenAI Function Callingå½¢å¼ï¼‰
const tools = [
  {
    type: 'function' as const,
    function: {
      name: 'searchAvailableSlots',
      description: 'ãƒ¡ãƒ³ã‚¿ãƒ¼ã®ç©ºãæ ã‚’æ¤œç´¢',
      parameters: {
        type: 'object',
        properties: {
          mentorId: { type: 'string', description: 'ãƒ¡ãƒ³ã‚¿ãƒ¼IDï¼ˆä»»æ„ï¼‰' },
          date: { type: 'string', format: 'date', description: 'æ—¥ä»˜' },
          subject: { type: 'string', description: 'ç§‘ç›®' }
        },
        required: ['date', 'subject']
      },
      strict: true // Structured Outputsæœ‰åŠ¹åŒ–
    }
  },
  {
    type: 'function' as const,
    function: {
      name: 'createReservation',
      description: 'äºˆç´„ã‚’ä½œæˆ',
      parameters: {
        type: 'object',
        properties: {
          mentorId: { type: 'string' },
          slotId: { type: 'string' },
          message: { type: 'string' }
        },
        required: ['mentorId', 'slotId']
      },
      strict: true
    }
  },
  {
    type: 'function' as const,
    function: {
      name: 'generateStudyMaterial',
      description: 'AIæ•™æã‚’ç”Ÿæˆ',
      parameters: {
        type: 'object',
        properties: {
          subject: { type: 'string' },
          topic: { type: 'string' },
          difficulty: { type: 'string', enum: ['beginner', 'intermediate', 'advanced'] }
        },
        required: ['subject', 'topic']
      },
      strict: true
    }
  }
];

export async function POST(req: NextRequest) {
  try {
    const { message, userId } = await req.json();

    // OpenAI Function Callingã§æ„å›³è§£æ
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini', // ã‚³ã‚¹ãƒˆåŠ¹ç‡ã®è‰¯ã„ãƒ¢ãƒ‡ãƒ«
      messages: [
        {
          role: 'system',
          content: 'ã‚ãªãŸã¯åŒ»å­¦ç”Ÿã®ãŸã‚ã®å­¦ç¿’æ”¯æ´ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æ±‚ã‚’ç†è§£ã—ã€é©åˆ‡ãªãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚'
        },
        { role: 'user', content: message }
      ],
      tools,
      tool_choice: 'auto',
      temperature: 0.3 // ä¸€è²«æ€§ã®ã‚ã‚‹å¿œç­”ã®ãŸã‚ä½ã‚ã«è¨­å®š
    });

    const responseMessage = completion.choices[0].message;

    // ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ãŒã‚ã‚‹å ´åˆ
    if (responseMessage.tool_calls) {
      const results = [];

      // ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ãªãƒ„ãƒ¼ãƒ«ã¯åŒæ™‚ã«å‡¦ç†
      const toolPromises = responseMessage.tool_calls.map(async (toolCall) => {
        const functionName = toolCall.function.name;
        const args = JSON.parse(toolCall.function.arguments);

        // å„ãƒ„ãƒ¼ãƒ«ã«å¯¾å¿œã™ã‚‹APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å‘¼ã³å‡ºã—
        const apiResponse = await fetch(`/api/${functionName}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-user-id': userId
          },
          body: JSON.stringify(args)
        });

        return {
          tool_call_id: toolCall.id,
          role: 'tool' as const,
          content: await apiResponse.text()
        };
      });

      const toolResults = await Promise.all(toolPromises);

      // ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œçµæœã‚’å«ã‚ã¦æœ€çµ‚å¿œç­”ã‚’ç”Ÿæˆ
      const finalCompletion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          ...completion.choices[0].message,
          ...toolResults
        ],
        temperature: 0.7
      });

      return NextResponse.json({
        response: finalCompletion.choices[0].message.content,
        toolsUsed: responseMessage.tool_calls.map(tc => tc.function.name)
      });
    }

    // ç›´æ¥å¿œç­”ã®å ´åˆ
    return NextResponse.json({
      response: responseMessage.content
    });

  } catch (error) {
    console.error('Intent processing error:', error);
    return NextResponse.json(
      { error: 'Intent processing failed' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒ

### ä¸»è¦ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆDrizzle Schemaï¼‰

```typescript
// db/schema.ts
import { pgTable, uuid, text, timestamp, integer, boolean, jsonb, decimal } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ï¼ˆClerké€£æºï¼‰
export const users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  clerkId: text("clerk_id").notNull().unique(),
  email: text("email").notNull().unique(),
  name: text("name"),
  role: text("role").notNull().default("student"), // student, mentor, admin
  subscriptionTier: text("subscription_tier").notNull().default("freemium"),
  profileImageUrl: text("profile_image_url"),
  bio: text("bio"),
  skills: jsonb("skills").$type<string[]>(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³
export const subscriptions = pgTable("subscriptions", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull().references(() => users.id),
  stripeCustomerId: text("stripe_customer_id").notNull().unique(),
  stripeSubscriptionId: text("stripe_subscription_id").unique(),
  stripePriceId: text("stripe_price_id"),

  tier: text("tier").notNull(), // FREEMIUM, STARTER, BASIC, PREMIUM
  status: text("status").notNull().default("active"), // active, canceled, past_due

  currentPeriodStart: timestamp("current_period_start"),
  currentPeriodEnd: timestamp("current_period_end"),
  cancelAtPeriodEnd: boolean("cancel_at_period_end").notNull().default(false),

  // ä½¿ç”¨é‡è¿½è·¡
  aiMaterialsUsed: integer("ai_materials_used").notNull().default(0),
  reservationsUsed: integer("reservations_used").notNull().default(0),

  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// ãƒ¡ãƒ³ã‚¿ãƒ¼æƒ…å ±
export const mentors = pgTable("mentors", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull().references(() => users.id).unique(),

  // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«
  specialties: jsonb("specialties").$type<string[]>(),
  qualifications: jsonb("qualifications").$type<string[]>(),
  university: text("university"),
  graduationYear: integer("graduation_year"),

  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
  rating: decimal("rating", { precision: 3, scale: 2 }).default("0"),
  totalSessions: integer("total_sessions").notNull().default(0),

  // åç›Šã‚·ã‚§ã‚¢
  revenueShareRate: decimal("revenue_share_rate", { precision: 3, scale: 2 }).default("0.70"),
  totalEarnings: decimal("total_earnings", { precision: 10, scale: 2 }).default("0"),

  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// ãƒ¬ãƒƒã‚¹ãƒ³ã‚¹ãƒ­ãƒƒãƒˆï¼ˆãƒ¡ãƒ³ã‚¿ãƒ¼ã®äºˆç´„å¯èƒ½æ™‚é–“ï¼‰
export const lessonSlots = pgTable("lesson_slots", {
  id: uuid("id").primaryKey().defaultRandom(),
  mentorId: uuid("mentor_id").notNull().references(() => users.id),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  price: decimal("price", { precision: 10, scale: 2 }).notNull(),
  maxCapacity: integer("max_capacity").notNull().default(1),
  currentCapacity: integer("current_capacity").notNull().default(0),
  status: text("status").notNull().default("available"), // available, booked, cancelled
  recurringId: uuid("recurring_id"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// äºˆç´„
export const reservations = pgTable("reservations", {
  id: uuid("id").primaryKey().defaultRandom(),
  slotId: uuid("slot_id").notNull().references(() => lessonSlots.id),
  studentId: uuid("student_id").notNull().references(() => users.id),
  mentorId: uuid("mentor_id").notNull().references(() => users.id),
  status: text("status").notNull().default("pending"), // pending, approved, paid, completed, cancelled
  paymentStatus: text("payment_status").notNull().default("pending"),
  stripeSessionId: text("stripe_session_id"),
  stripePaymentIntentId: text("stripe_payment_intent_id"),
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  notes: text("notes"),
  cancelReason: text("cancel_reason"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// AIç”Ÿæˆæ•™æ
export const aiGeneratedMaterials = pgTable("ai_generated_materials", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull().references(() => users.id),

  subject: text("subject").notNull(),
  topic: text("topic").notNull(),
  difficulty: text("difficulty").notNull(), // beginner, intermediate, advanced

  content: jsonb("content").notNull(), // ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„
  metadata: jsonb("metadata"), // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³æ•°ãªã©ï¼‰

  // ã‚³ã‚¹ãƒˆè¿½è·¡
  tokensUsed: integer("tokens_used").notNull().default(0),
  estimatedCost: decimal("estimated_cost", { precision: 10, scale: 4 }).default("0"),

  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
export const messages = pgTable("messages", {
  id: uuid("id").primaryKey().defaultRandom(),
  reservationId: uuid("reservation_id").references(() => reservations.id),
  senderId: uuid("sender_id").notNull().references(() => users.id),
  receiverId: uuid("receiver_id").notNull().references(() => users.id),
  content: text("content").notNull(),
  attachments: jsonb("attachments").$type<{ url: string; type: string; name: string }[]>(),
  isRead: boolean("is_read").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©
export const usersRelations = relations(users, ({ many }) => ({
  mentorSlots: many(lessonSlots),
  studentReservations: many(reservations),
  sentMessages: many(messages),
  aiMaterials: many(aiGeneratedMaterials),
  subscriptions: many(subscriptions),
}));

export const reservationsRelations = relations(reservations, ({ one, many }) => ({
  slot: one(lessonSlots, {
    fields: [reservations.slotId],
    references: [lessonSlots.id],
  }),
  student: one(users, {
    fields: [reservations.studentId],
    references: [users.id],
  }),
  mentor: one(users, {
    fields: [reservations.mentorId],
    references: [users.id],
  }),
  messages: many(messages),
}));
```

---

## ğŸ”Œ APIè¨­è¨ˆ

### REST APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ§‹æˆ

```typescript
// API Routesæ§‹é€ 
app/api/
â”œâ”€â”€ auth/
â”‚   â””â”€â”€ webhook/          # Clerk webhook
â”œâ”€â”€ stripe/
â”‚   â””â”€â”€ webhook/          # Stripe webhook
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ intent/          # è‡ªç„¶è¨€èªæ„å›³è§£æ
â”‚   â””â”€â”€ generate/        # æ•™æç”Ÿæˆ
â”œâ”€â”€ subscriptions/
â”‚   â”œâ”€â”€ create/          # ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ä½œæˆ
â”‚   â”œâ”€â”€ update/          # ãƒ—ãƒ©ãƒ³å¤‰æ›´
â”‚   â””â”€â”€ cancel/          # è§£ç´„
â”œâ”€â”€ reservations/
â”‚   â”œâ”€â”€ search/          # ç©ºãæ æ¤œç´¢
â”‚   â”œâ”€â”€ create/          # äºˆç´„ä½œæˆ
â”‚   â””â”€â”€ [id]/           # äºˆç´„è©³ç´°ãƒ»æ›´æ–°ãƒ»å‰Šé™¤
â”œâ”€â”€ mentors/
â”‚   â”œâ”€â”€ search/          # ãƒ¡ãƒ³ã‚¿ãƒ¼æ¤œç´¢
â”‚   â”œâ”€â”€ [id]/           # ãƒ¡ãƒ³ã‚¿ãƒ¼è©³ç´°
â”‚   â””â”€â”€ slots/          # ç©ºãæ ç®¡ç†
â””â”€â”€ payments/
    â”œâ”€â”€ create-intent/   # æ”¯æ‰•ã„ä½œæˆ
    â””â”€â”€ confirm/         # æ”¯æ‰•ã„ç¢ºèª
```

### APIãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¨™æº–åŒ–

```typescript
// lib/api-response.ts
export class ApiResponse {
  static success<T>(data: T, meta?: any) {
    return NextResponse.json({
      success: true,
      data,
      meta,
      timestamp: new Date().toISOString()
    });
  }

  static error(message: string, code?: string, status = 400) {
    return NextResponse.json(
      {
        success: false,
        error: {
          message,
          code: code || 'UNKNOWN_ERROR'
        },
        timestamp: new Date().toISOString()
      },
      { status }
    );
  }
}

// ä½¿ç”¨ä¾‹
export async function GET(req: NextRequest) {
  try {
    const data = await fetchData();
    return ApiResponse.success(data);
  } catch (error) {
    return ApiResponse.error('Failed to fetch data', 'FETCH_ERROR', 500);
  }
}
```

---

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

### èªè¨¼ãƒ»èªå¯

```typescript
// middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';

const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/api/(?!auth|stripe/webhook)(.*)'
]);

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) {
    await auth.protect();
  }
});

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

### Rate Limiting

```typescript
// lib/rate-limiter.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

export const rateLimiter = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'), // 10ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/10ç§’
  analytics: true,
  prefix: '@upstash/ratelimit',
});

// API Routeã§ã®ä½¿ç”¨
export async function POST(req: NextRequest) {
  const ip = req.headers.get('x-forwarded-for') ?? 'anonymous';
  const { success, limit, reset, remaining } = await rateLimiter.limit(ip);

  if (!success) {
    return NextResponse.json(
      { error: 'Rate limit exceeded' },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': new Date(reset).toISOString(),
        }
      }
    );
  }

  // é€šå¸¸ã®å‡¦ç†
}
```

### å…¥åŠ›æ¤œè¨¼

```typescript
// lib/validation.ts
import { z } from 'zod';

// ã‚¹ã‚­ãƒ¼ãƒå®šç¾©
export const CreateReservationSchema = z.object({
  mentorId: z.string().cuid(),
  slotId: z.string().cuid(),
  message: z.string().max(500).optional()
});

// ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
export function validateRequest<T>(schema: z.ZodSchema<T>) {
  return async (req: NextRequest) => {
    try {
      const body = await req.json();
      const validated = schema.parse(body);
      return { success: true, data: validated };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          success: false,
          error: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        };
      }
      return { success: false, error: 'Invalid request' };
    }
  };
}
```

---

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

```typescript
// lib/cache.ts
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

export class Cache {
  static async get<T>(key: string): Promise<T | null> {
    return await redis.get(key);
  }

  static async set(key: string, value: any, ttl?: number) {
    if (ttl) {
      await redis.setex(key, ttl, value);
    } else {
      await redis.set(key, value);
    }
  }

  static async invalidate(pattern: string) {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }
}

// ä½¿ç”¨ä¾‹ï¼šãƒ¡ãƒ³ã‚¿ãƒ¼æƒ…å ±ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
export async function getMentorWithCache(mentorId: string) {
  const cacheKey = `mentor:${mentorId}`;

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
  const cached = await Cache.get(cacheKey);
  if (cached) return cached;

  // DBã‹ã‚‰å–å¾—ï¼ˆDrizzleï¼‰
  const [mentor] = await db
    .select()
    .from(mentors)
    .where(eq(mentors.id, mentorId))
    .limit(1);

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ï¼ˆ5åˆ†é–“ï¼‰
  await Cache.set(cacheKey, mentor, 300);

  return mentor;
}
```

### OpenAI APIã‚³ã‚¹ãƒˆæœ€é©åŒ–

```typescript
// lib/openai-optimizer.ts
export class OpenAIOptimizer {
  // ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã®äº‹å‰æ¨å®š
  static estimateTokens(text: string): number {
    // ç°¡æ˜“çš„ãªæ¨å®šï¼ˆæ—¥æœ¬èªã¯1æ–‡å­—â‰’1ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰
    return Math.ceil(text.length * 1.2);
  }

  // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æœ€é©åŒ–
  static optimizePrompt(prompt: string, maxTokens = 1000): string {
    const estimated = this.estimateTokens(prompt);
    if (estimated > maxTokens) {
      // é•·ã™ãã‚‹å ´åˆã¯è¦ç´„ã‚’è¦æ±‚
      return `ä»¥ä¸‹ã®å†…å®¹ã‚’${maxTokens}ãƒˆãƒ¼ã‚¯ãƒ³ä»¥å†…ã§è¦ç´„ã—ã¦ãã ã•ã„ï¼š\n${prompt}`;
    }
    return prompt;
  }

  // ãƒ¢ãƒ‡ãƒ«é¸æŠã®æœ€é©åŒ–
  static selectModel(complexity: 'low' | 'medium' | 'high') {
    switch (complexity) {
      case 'low':
        return 'gpt-3.5-turbo'; // æœ€ã‚‚å®‰ä¾¡
      case 'medium':
        return 'gpt-4o-mini'; // ãƒãƒ©ãƒ³ã‚¹å‹
      case 'high':
        return 'gpt-4o'; // é«˜ç²¾åº¦
    }
  }

  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  static async getCachedOrGenerate(
    key: string,
    generator: () => Promise<string>,
    ttl = 3600 // 1æ™‚é–“
  ): Promise<string> {
    const cached = await Cache.get(key);
    if (cached) return cached as string;

    const result = await generator();
    await Cache.set(key, result, ttl);
    return result;
  }
}
```

---

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæ§‹æˆ

### ç’°å¢ƒå¤‰æ•°

```env
# .env.local
# Authentication
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxx
CLERK_SECRET_KEY=sk_test_xxx
CLERK_WEBHOOK_SECRET=whsec_xxx

# Database
DATABASE_URL=postgresql://user:password@host/db

# Redis Cache
UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=xxx

# OpenAI
OPENAI_API_KEY=sk-xxx
OPENAI_ORGANIZATION=org-xxx

# Stripe
STRIPE_PUBLISHABLE_KEY=pk_test_xxx
STRIPE_SECRET_KEY=sk_test_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx

# Email
RESEND_API_KEY=re_xxx
```

### Vercelãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š

```json
// vercel.json
{
  "functions": {
    "app/api/ai/generate/route.ts": {
      "maxDuration": 30
    },
    "app/api/ai/intent/route.ts": {
      "maxDuration": 25
    }
  },
  "env": {
    "NODE_ENV": "production"
  }
}
```

---

## ğŸ“… Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼çµ±åˆ

### çµ±åˆæ–¹é‡

**ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼UIã‚’è‡ªå‰å®Ÿè£…ã›ãšã€Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«å§”è­²**ã™ã‚‹ã“ã¨ã§é–‹ç™ºã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ä½¿ã„æ…£ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§äºˆç´„ã‚’ç®¡ç†ã§ãã¾ã™ã€‚

### çµ±åˆãƒã‚¤ãƒ³ãƒˆ

```typescript
// services/google-calendar.service.ts
import { google } from 'googleapis';

export class GoogleCalendarService {
  private calendar = google.calendar('v3');

  // äºˆç´„ç¢ºå®šæ™‚: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ
  async createReservationEvent(reservation: Reservation) {
    const event = {
      summary: `ãƒ¬ãƒƒã‚¹ãƒ³: ${reservation.subject}`,
      description: `ãƒ¡ãƒ³ã‚¿ãƒ¼: ${reservation.mentor.name}\n${reservation.notes || ''}`,
      start: {
        dateTime: reservation.startTime.toISOString(),
        timeZone: 'Asia/Tokyo',
      },
      end: {
        dateTime: reservation.endTime.toISOString(),
        timeZone: 'Asia/Tokyo',
      },
      attendees: [
        { email: reservation.student.email },
        { email: reservation.mentor.email },
      ],
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 }, // 1æ—¥å‰
          { method: 'popup', minutes: 30 },      // 30åˆ†å‰
        ],
      },
    };

    return await this.calendar.events.insert({
      calendarId: 'primary',
      requestBody: event,
      sendUpdates: 'all', // å…¨å‚åŠ è€…ã«é€šçŸ¥
    });
  }

  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚: ã‚¤ãƒ™ãƒ³ãƒˆå‰Šé™¤
  async cancelReservationEvent(googleEventId: string) {
    return await this.calendar.events.delete({
      calendarId: 'primary',
      eventId: googleEventId,
      sendUpdates: 'all',
    });
  }

  // ãƒ¡ãƒ³ã‚¿ãƒ¼ç©ºãæ åŒæœŸï¼ˆPhase 2ï¼‰
  async syncMentorAvailability(mentorCalendarId: string, days = 30) {
    const now = new Date();
    const future = new Date();
    future.setDate(future.getDate() + days);

    const response = await this.calendar.events.list({
      calendarId: mentorCalendarId,
      timeMin: now.toISOString(),
      timeMax: future.toISOString(),
      singleEvents: true,
      orderBy: 'startTime',
    });

    // ãƒ“ã‚¸ãƒ¼æ™‚é–“ã‚’é™¤å¤–ã—ã¦ç©ºãæ ã‚’ç”Ÿæˆ
    return this.generateAvailableSlots(response.data.items);
  }
}
```

### å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º

#### Phase 1ï¼ˆMVPï¼‰: åŸºæœ¬çš„ãªã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ
- âœ… äºˆç´„ç¢ºå®šæ™‚ã«è‡ªå‹•ã§Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ
- âœ… ãƒ¡ãƒ³ã‚¿ãƒ¼ãƒ»å­¦ç”ŸåŒæ–¹ã«ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼é€ä¿¡
- âœ… ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆå‰Šé™¤

#### Phase 2ï¼ˆæˆé•·æœŸï¼‰: åŒæ–¹å‘åŒæœŸ
- âš ï¸ ãƒ¡ãƒ³ã‚¿ãƒ¼ã®Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰ç©ºãæ ã‚’è‡ªå‹•æ¤œå‡º
- âš ï¸ å¤–éƒ¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¢ãƒ—ãƒªã¨ã®åŒæœŸ
- âš ï¸ è¤‡æ•°ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®çµ±åˆç®¡ç†

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒè¿½åŠ 

```typescript
// db/schema.ts ã«è¿½åŠ 

// äºˆç´„ãƒ†ãƒ¼ãƒ–ãƒ«ã«Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
export const reservations = pgTable("reservations", {
  // ... æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

  // Google Calendarçµ±åˆ
  googleEventId: text("google_event_id"),     // Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆID
  googleEventLink: text("google_event_link"), // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¸ã®ãƒªãƒ³ã‚¯
});

// ãƒ¡ãƒ³ã‚¿ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã«Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
export const mentors = pgTable("mentors", {
  // ... æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

  // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸè¨­å®š
  googleCalendarId: text("google_calendar_id"),          // ãƒ¡ãƒ³ã‚¿ãƒ¼ã®Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ID
  calendarSyncEnabled: boolean("calendar_sync_enabled").default(false),
  lastSyncedAt: timestamp("last_synced_at"),
});
```

### ãƒ¡ãƒªãƒƒãƒˆ

1. **é–‹ç™ºã‚³ã‚¹ãƒˆå‰Šæ¸›**
   - ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼UIã®å®Ÿè£…ä¸è¦ï¼ˆæ¨å®š20-30æ™‚é–“ã®å‰Šæ¸›ï¼‰
   - ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ã‚‚è‡ªå‹•

2. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å‘ä¸Š**
   - ä½¿ã„æ…£ã‚ŒãŸGoogleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã§ç®¡ç†
   - ä»–ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨çµ±åˆè¡¨ç¤º
   - ã‚¹ãƒãƒ›ãƒ»PCã§è‡ªå‹•åŒæœŸ

3. **ä¿å®ˆæ€§å‘ä¸Š**
   - GoogleãŒã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ã‚’ä¿å®ˆ
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚‚è‡ªå‹•

---

## ğŸ“ˆ å°†æ¥ã®æ‹¡å¼µæ€§

### Phase 2ä»¥é™ã®æ¤œè¨äº‹é …

1. **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–**
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°5,000è¶…ãˆãŸæ®µéšã§æ¤œè¨
   - AIæ©Ÿèƒ½ã‹ã‚‰æ®µéšçš„ã«åˆ†é›¢
   - MCPã®æ¡ç”¨ã‚‚é¸æŠè‚¢ã¨ã—ã¦æ¤œè¨å¯èƒ½

2. **B2B APIå…¬é–‹**
   - åŒ»ç™‚æ©Ÿé–¢å‘ã‘APIæä¾›
   - ä½¿ç”¨é‡ãƒ™ãƒ¼ã‚¹ã®èª²é‡‘ãƒ¢ãƒ‡ãƒ«
   - APIã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ã®å°å…¥

3. **ã‚°ãƒ­ãƒ¼ãƒãƒ«å±•é–‹**
   - å¤šè¨€èªå¯¾å¿œ
   - CDNæ´»ç”¨
   - ãƒªãƒ¼ã‚¸ãƒ§ãƒ³åˆ¥ãƒ‡ãƒ—ãƒ­ã‚¤

4. **é«˜åº¦ãªAIæ©Ÿèƒ½**
   - RAGã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰
   - ãƒ™ã‚¯ãƒˆãƒ«DBï¼ˆPineconeç­‰ï¼‰å°å…¥
   - ã‚«ã‚¹ã‚¿ãƒ LLMãƒ•ã‚¡ã‚¤ãƒ³ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°

5. **ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼çµ±åˆæ‹¡å¼µ**
   - Outlookã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼APIå¯¾å¿œ
   - Appleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼APIå¯¾å¿œ
   - CalDAVãƒ—ãƒ­ãƒˆã‚³ãƒ«å¯¾å¿œ

---

## ğŸ“Š æˆåŠŸæŒ‡æ¨™ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

### KPIè¨­å®š

```typescript
// lib/metrics.ts
export const trackMetric = async (metric: {
  name: string;
  value: number;
  tags?: Record<string, string>;
}) => {
  // Vercel Analyticsã¸ã®é€ä¿¡
  if (typeof window !== 'undefined' && window.va) {
    window.va('event', {
      name: metric.name,
      value: metric.value,
      ...metric.tags
    });
  }

  // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã¯ãƒ­ã‚°å‡ºåŠ›
  if (typeof window === 'undefined') {
    console.log('[METRIC]', JSON.stringify(metric));
  }
};

// ä½¿ç”¨ä¾‹
await trackMetric({
  name: 'reservation.created',
  value: 1,
  tags: { tier: 'premium' }
});
```

### ä¸»è¦ãƒ¡ãƒˆãƒªã‚¯ã‚¹

- **ãƒ“ã‚¸ãƒã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹**
  - MRRï¼ˆæœˆæ¬¡çµŒå¸¸åç›Šï¼‰
  - ãƒ¦ãƒ¼ã‚¶ãƒ¼ç²å¾—ã‚³ã‚¹ãƒˆï¼ˆCACï¼‰
  - é¡§å®¢ç”Ÿæ¶¯ä¾¡å€¤ï¼ˆLTVï¼‰
  - ãƒãƒ£ãƒ¼ãƒ³ãƒ¬ãƒ¼ãƒˆ

- **æŠ€è¡“ãƒ¡ãƒˆãƒªã‚¯ã‚¹**
  - APIå¿œç­”æ™‚é–“ï¼ˆp50, p95, p99ï¼‰
  - ã‚¨ãƒ©ãƒ¼ç‡
  - OpenAI APIã‚³ã‚¹ãƒˆ
  - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡

---

## ğŸ”š ã¾ã¨ã‚

æœ¬ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€**ã‚·ãƒ³ãƒ—ãƒ«ã•ã¨å®Ÿè£…ã‚¹ãƒ”ãƒ¼ãƒ‰**ã‚’é‡è¦–ã—ã€MVPã‚’**150æ™‚é–“ï¼ˆ43æ—¥é–“ï¼‰**ã§å®Œæˆã•ã›ã‚‹ã“ã¨ã‚’ç›®æ¨™ã¨ã—ã¦ã„ã¾ã™ã€‚OpenAI Function Callingã¨REST APIã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚Šã€è‡ªç„¶è¨€èªå‡¦ç†ã‚’å«ã‚€é«˜åº¦ãªæ©Ÿèƒ½ã‚’ä½ã‚³ã‚¹ãƒˆã§å®Ÿç¾ã—ã€å°†æ¥çš„ãªæ‹¡å¼µæ€§ã‚‚ç¢ºä¿ã—ã¦ã„ã¾ã™ã€‚

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. âœ… Stripeè£½å“ãƒ»ä¾¡æ ¼è¨­å®šã®å®Ÿè£…
2. âœ… OpenAI Function Callingçµ±åˆã®å®Ÿè£…
3. âœ… åŸºæœ¬çš„ãªCRUD APIã®æ§‹ç¯‰
4. âœ… ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†æ©Ÿèƒ½ã®å®Ÿè£…
5. âœ… AIæ•™æç”Ÿæˆæ©Ÿèƒ½ã®å®Ÿè£…